Процессы в Linux

Программа это файл, в котором заложенны определенные действия.
При запуске программы рождается процесс, которые взаимодействует с ядром ОС по средствам системных вызовов.
Процесс - это абстрация, является изолированной средой в ОС, для котрой выделяются ядром ресурсы компьютера.

Системные вызовы:
fork() - создание процесса
стартует в одном процессе, завершается в двух (клонируется (но не польностью, делается соответствие процессу), например оболочка + сист. вызов fork()). Процессу родителю возвращается pid дочернего процесса. Дочернему процессу возвращается код 0
из wiki: fork() — системный вызов в Unix-подобных операционных системах, создающий новый процесс (потомок), который является практически полной копией процесса-родителя, выполняющего этот вызов.
Только ядро может создать процесс и только ядро может завершить его.
Из инета:
При вызове fork() возникают два полностью идентичных процесса. Весь код после fork() выполняется дважды, как в процессе-потомке, так и в процессе-родителе.
Процесс-потомок и процесс-родитель получают разные коды возврата после вызова fork(). Процесс-родитель получает идентификатор (PID) потомка. Если это значение будет отрицательным, следовательно при порождении процесса произошла ошибка. Процесс-потомок получает в качестве кода возврата значение 0, если вызов fork() оказался успешным.


exec() - загрузка (запуск) программы в процесс
способ запустить программу в linux. Работает в существующем процессе. Заменяет программу процесса на ту, что была передана exec() в качестве аргумента. Exec() семейство системных вызовов: execl, execle, execlp, execv, execve, execvp

exit() - завершение процесса
завершение работы программы в linux. Приводит к обычному завершению работы программы.После завершения программы ее переменная status будет доступна родительскому процессу (status - код возврата, 0 - без ошибок). exec() НЕ завершает процесс. После системного вызова exit() система высвобождает все ресурсы и в итоге остаётся только одна строчка информации - (родитель, идентификатор, код возврата и какая программа работала внутри этого процесса).

wait() - считывание кода возврата процесса
считывает код возврата дочернего процесса в linux. Код возврата может получить только процесс родитель. Приостанавливает выполнение текущего процесса до тех пор, пока дочерний процесс не прекратит выполнение. Получает код возврата дочернего процесса. После вызова wait() дочерний процесс полностью исчезает из системы. 

Так называемые процессы-зомби возникают, если потомок завершился, а родительский процесс не вызвал wait(). Для завершения процессов используют либо оператор возврата, либо вызов функции exit() со значением, которое нужно возвратить операционной системе. Операционная система оставляет процесс зарегистрированным в своей внутренней таблице данных, пока родительский процесс не получит кода возврата потомка, либо не закончится сам. В случае процесса-зомби его код возврата не передается родителю, и запись об этом процессе не удаляется из таблицы процессов операционной системы. При дальнейшей работе и появлении новых зомби таблица процессов может быть заполнена, что приведет к невозможности создания новых процессов.


В архитектуре intel существует 4 кольца защиты. Используется два:
0 - ядро ОС
3 - пространство пользователя

Самый первый процесс (в пространстве пользователя) в Linux то процесс системы инициализации - systemd (современные Linux), init (upstart, System V). В пространстве ядра - kthredd (kernel thred demon) (демон потоков ядра). Данные процессы создаются "из ничего"

Потоки - не имеют собственного адресного пространства, быстро работают, особенно на чтение. Потоки это легковесные процессы, работающие в общей памяти. Потоки создаются быстрее процессов. Контролирует демон потоков ядра. Потоки имеют своих родителей и свой идентифекатор.

Ядро работает в собственной области памяти.

Процессы всегда имеют собственное адресное пространство, другие процессы не могут влезть в память другого процесса.


PID - process id
PPID - parent process id

Пример:
запускаем ls
1) bash -> fork() ядру
ядро выполняет fork()

bash go parent line

bash go chaild line (make clone)

2) команда (введеная в командрую оболочку) подгружается с помощью exec()
выполняется команда ls (у нее есть ремурсы, она 
3) отработала (вывела нам на экран содержимое каталога)) и сообщает свой системный вызов exit()
освобождаются ресурсы, которые использовались
4) системному вызову wait() передаётся код возврата родителю


Дескриптор файла - это целое число без знака, с помощью которого процесс обращается к открытому файлу.
Дескрипторы файлов выполняют роль индексов таблицы дескрипторов, которая расположена в области u_block и создается ядром для каждого процесса. Чаще всего процесс получает дескрипторы с помощью операций open и creat, а также путем наследования от родительского процесса. При выполнении операции fork таблица дескрипторов копируется для дочернего процесса. В результате дочерний процесс получает право обращаться к файлам родительского процесса.
В Linux библиотека libc открывает для каждого запущенного приложения(процесса) 3 файл дескриптора, с номерами 0,1,2. Больше информации вы можете найти по ссылкам man stdio и man stdout.
Файл дескриптор 0 называется STDIN и ассоциируется с вводом данных у приложения
Файл дескриптор 1 называется STDOUT и используется приложениями для вывода данных, например командами print
Файл дескриптор 2 называется STDERR и используется приложениями для вывода данных, сообщающих об ошибке



Демон (daemon) - процесс, работающий в фоновом режиме без прямого взаимодействия с пользователем (без привязки к терминалу). В названии будет последняя буква d. Не принимает сигналы (ctrl+c, ctrl+z), ввод, вывод и ошибки (потоки) направлены в другием места (см. file descriptor в /proc).


Зомби (Zombie) - процесс, который ожидает wait() от родителя, состоит только из одной строки (код состояния) в таблице процессов. Не потребляет ресурсы. Является обязательным состоянием любого процесса (находится между exit() и wait()). Его нельзя убить (вообще никак, командой kill), в таком состоянии может находиться до бесконечности. Единственный способ его завершить - это убить родителя, что бы он стал сиротой и его усыновил\удочерил systemd\init и считал код возврата (послал wait()) или написать скрипт - return 0, можно подключиться к debugger и послать wait().

Сироты - процессы, которые остались без родителя, они будут мгновенно усыновлены процессом systemd\init, этот процесс контролируется ядром.


Процесс возвращает блоки данных через shared memory (ОЗУ) или hdd или ipc (inter process communication, межпроцессовая коммуникация).




