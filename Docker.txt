DOCKER

Docker состоит из image и контейнеров 
Контейнеры запускаются из образов

Образы - readonly 

DockerHub - публичное хранилище образов

Контейнеры являются изолированными

Команды:
1. docker pull "название"                                                              //скачать образ в локальное хранилище
2. Скачать image из docker hub и сразу запустить контейнер docker run "название"
(i) После запуска, контейнер отрабатывает и останавливается.
3. Посмотреть какие есть  контейнеры:
docker ps                                                                              //только запущенные
            -a                                                                         //все контейнеры

(i) Вывести список локальных образов (image):
docker images

(i) Удалить все STOP контейнеры: 
docker container prune

* Хорошие примеры docker run:

docker run
              -it      //интерактивный терминал (подключиться сразу после запуска контейнера к терминалу)
              -d       //запускать в фоновом режиме
              --rm     //автоматическое удаление контейнера после завершения 

docker run -it busybox

(i) Образы состоят из СЛОЁВ

Посмотреть информацию по контейнеру:
docker container inspect id                                   //id контейнера. Можно grep по выводу: | grep IPAdress

Остановить контейнер:
docker stop id

(i) В образах используются тэги, тэг - версия
тег latest (последняя версия образа)
пример:
docker run hellow-world
docker run busybox:latest

Выполнение дополнительной команды запущенном контейнере (сразу откроется bash, после выхода из bash контейнера - он не остановится, т.к. работает корневой процесс, например: nginx)
docker exec -it id_контейнера или имя_контейнера bash         //exec сработает только для уже запущенных (работающих) контейнеров

(i) Задать имя контейнеру                                     //если не задать - генерируется автоматически
    --name имя_контейнера

Публикация порта (mapping port):
docker run -p 8080:80 nginx                                   //8080 - внешний порт, 80 - внутренний (в контейнере)

Запуск контейнера в фоне:
docker run -d nginx

Публицация томов (каталогов) (mapping dir):
docker run -v ${pwd}:/usr/share/nginx/html nginx
/usr/share/nginx/html    - путь к каталогу внутри контейнера
${pwd}                   - путь к локальному каталогу, можно писать абсолютный путь, или текущий pwd
На хосте надо создать каталог и файл который будем пробрасывать в контейнер: ~/nginx/index.html          //пробрасывать надо именно каталог
(i) Файл index.html проброшенный с локальной машины будет доступен в контейнере (default файл (index.html и другие) в запущенном контейнере будет заменён на проброшенные с локальной маишны)
Пробросить (map) можно КАТАЛОГ целиком
(i) Пробрасывать правильнее абсолютный путь

Автоматическое удаление контейнеров после остановки:
  --rm

(i) можно разбивать контейнеры на строки, для этого используется обратный слэш в конце строки (\)
Пример:
docker run \
-- name mynginx \
-p 8080:80 \
-d \
--rm \
nginx




СОЗДАНИЕ ОБРАЗОВ (этапы)
1. Для создания образа необходим Dockerfile
   один dockerfile = один образ
2. Dockerfile помещают в корень каталога с приложением
3. Dockerfile содержит инструкции по созданию образа
4. При создании образа можно указать имя и тэг для образа (рекомендуется)
5. При создании собственного образа берется базовый образ
6. Образы  состоят из слоёв
7. Dockerfile пишется с большой буквы D

Пример Dockerfile:
FROM python:alpine          //python - базовый образ, alpine - самая лёгкая версия linux
WORKDIR /app                //это директория будет создана в контейнере
COPY . .                    //скопирует файлы из . в /app
CMD ["python", "main.py"]   //python - процесс, main.py - параметр запуска = main.py будет запущен внутри контейнера

1. Запуск создания нового своего образа:
1.1 в каталоге с проектом есть Dockerfile
1.2 запустить команду в директории с проектом, где есть Dockerfile      //имя и тэг будут сгенерированы
docker build .
(i)  . - это путь к Dockerfile

Если название отличается от Dockerfile, например dockerfile.dev или dockerfile-prod, то при указании Dockerfile надо использовать параметр:
  -f

(i) Добавление имени и тэга образу:
  -t mycontainer:4.1.3
если не указать тэг, то будет автоматом поставлен latest

() Копировать dockerfile внутрь образа не нужно, можно и не копировать любые другие файлы из WORKDIR, для этого используют файл:
.dockerignore



DOCKER COMPOSE
Используется декларативный подход.
С помощью yml файлов описывается желаемый результат

Пример docker-compose.yml:
version: '3'
services:
  app:                  // название (контейнер 1)
    build: ./app        // создание образа
  mongo:                // название (контейнер 1)
    image: mongo        // название образа (официального)

(i) Спомощью docker-compose создаются инструкции более высокого уровня

Принципы написания yaml файлов:
1. Словари списки
fruts:
  - banana
  - apple
  - orange

2. Словари
Pen:
  color: red
  model:
    type: pen
    material: plastic
  price: 2

1) Словари - перечисление
2) Слевари - ключ: значение
(i) Обязательно использовать два (2) пробела
(i) В словарь можно включать список

(i) Все контейнеры (сервисы) задаются одной командой:
docker-compose up

Автоматически создаются необходимые образы на основании dockerfile

Автоматически содздаётся отдельная сеть для контейнеро и они подключаются к ней (видят друг друга)
Во внутренней сети можно использовать DNS имена (сервисов)

Остановить все контейнеры (сервисы) поднятые с помощью docker-compose:
docker-compose down
(i) Контейнеры останавливаются и удаляются

Ключи docker-compose up:
  -d          //запуск в фоне
  --build     //пересоздать образы (необходимо задавать если были изменения в исходных файлов (для пересборки))

(i) В docker-compose контейнеры описываются как сервисы!

В docker-compose можно задать переменные для сервиса (пример):
  environment:
    MYSQL_DATABASE: time_db
    MY_ROOT_PASSWORD: qwerty123


ПРИМЕР ПРОСТОГО DOCKER-COMPOSE YML ФАЙЛА:
-----===start===----- 
version: '3'
services:
  
  frontend:
    build: ./frontend
    ports:
      - '3000:3000'                 //внешний:внутренний
    restart: always                 //автоперезапуск в случае ошибок

  api:
    build: ./api
    ports:
      - '5555:5000'
    restart: always
    depends_on:
      - mysql                       //запуск после сервиса (контейнера) mysql, зависимость

  mysql:
    image: mysql
    environment:
      MYSQL_ROOT_PASSWORD: mypasswd
      MYSQL_DATABASE: time_db
    restart: always
    volumes:                        //mapping томов
      mysql_data:/var/lib/mysql     //map тома внутри docker_host к разделу внутри контейнера
  
  adminer:
    image: adminer
    restart: always
    ports:
      - '8888:8080'

volumes:
  mysql_data                         //создаёт том внутри docker host

-----===end===----- 

(i) еще круче (учебный проект с переделкой): 
https://github.com/pshiki/myAdminScripts/blob/main/linux/docker/time-app/docker-compose.yml




MAPPING ТОМОВ в DOCKER
Есть два варианта:
1. Mapping томов в виде конкретного каталога (непосредствено с сервера)
2. Mapping томов внутри docker хоста (необходим для того, что бы разные контейнеры могли обращаться к одному и тому же каталогу)

  ____________________________________________________________
 | Linux Server/Workstation                                   |
 |                                                            |
 |                 |------------------------------------------|  
 |                 | Docker                                   |
 |			       |                     ---------------------|
 |			       |                     |   Container        |
 |				   |                     |                    |
 |                 |                     |                    |
 |(1)/var/mydata <-|---------------------|-->  /var/mydata    |
 |	               |                     |                    |
 |	               |(2)/var/lib/mysql <--|-->  /var/lib/mysql |
 |                 |                     |                    | 
 |                 |                      --------------------|             
 |                  ------------------------------------------|
 |____________________________________________________________|


Пример 1. Mapping с компьютера
services:
  nginx:
    volumes:
	  - ./www:/usr/share/nginx/html

	  
Пример 2. Mapping тома внутри Docker (данный вариант отлично подходит для контейнеров использующих Базы Данных)
services:
  mysql:
    image: mysql
	restart: always
	evironment:
	  MYSQL_ROOT_PASSWOR: PassWD
	  MYSQL_DATABASE: db_name
	  
	volumes:
	- mysql_data:/var/lib/mysql
	
volumes:
  mysql_data:


(i) Посмотреть где находится созданный том (по варианту 2 (внутри Docker)):
docker volume ls

Более подробная информация о томе внутри Docker:
docker inspect название_тома


Пример. Использование 1 варианта. Mapping каталога с исключениями
sevices:
  frontend:
    build: ./frontend
	  volumes:
	    - /app/node_modules       //оставить каталог внутри контейнера и не заменять его
		- ./frontend:/app         //mapp внешнего каталога в контейнер
		
		
(i) /app/node_modules внутри контейнера создаётся при инструкции npm install в Dockerfile

(ii) в примере: внутри контейнера /app/node_modules не будет перезаписана (той, что mapp с компьютера ./frontend)

(iii) Теперь все изменения в коде (на server/workstation) будут сразу применяться в контейнере (не нужно пересобирать образ) 
* Это удобно для DEV 






















---------==============---------
ОСНОВНЫЕ ПАРАМЕТРЫ ЗАПУСКА
-d       запуск в фоне
-it      запустить интерактивный терминал
-p       пробросить порт  3333:3000                  //внешний:внутренний
-v       пробросить каталогк   ./dir1/dir2:/usr/share/html
--name   задать имя контейнеу
--rm     удалить контейнер сразу после остановки
-e       задать переменную среды MY_ENV_VAR=test
-w       рабочая директория внутри контейнера
---------==============---------
---------==============---------
КОМАНДЫ DOCKER
docker run
       stop
       pull
       contaiter inspect
       exec
       images
       logs id_container
       volume ls
       inspect
       contaiter prune
       login
       image prune -a
---------==============---------
---------==============---------
docker-compose up\down -d
                       --build
               -f dockerfile.pub.yml up\down
---------==============---------
















































